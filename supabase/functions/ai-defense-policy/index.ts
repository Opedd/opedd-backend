import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { corsHeaders, errorResponse, successResponse } from "../_shared/cors.ts";
import { createServiceClient } from "../_shared/auth.ts";

// Known AI crawlers to block from unlicensed content
const AI_CRAWLERS = [
  "GPTBot",
  "Google-Extended",
  "CCBot",
  "anthropic-ai",
  "Claude-Web",
  "Bytespider",
  "Amazonbot",
  "FacebookBot",
  "Applebot-Extended",
  "PerplexityBot",
  "YouBot",
  "Diffbot",
  "Cohere-ai",
  "AI2Bot",
  "Omgilibot",
  "img2dataset",
];

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  if (req.method !== "GET") {
    return errorResponse("Method not allowed", 405);
  }

  try {
    const url = new URL(req.url);
    const publisherId = url.searchParams.get("publisher_id");
    const format = url.searchParams.get("format") || "json"; // json, robots, ai_txt

    if (!publisherId) {
      return errorResponse("publisher_id is required");
    }

    const supabase = createServiceClient();

    // Fetch publisher
    const { data: publisher, error: pubError } = await supabase
      .from("publishers")
      .select("id, name, website_url")
      .eq("id", publisherId)
      .single();

    if (pubError || !publisher) {
      return errorResponse("Publisher not found", 404);
    }

    // Fetch all publisher's articles
    const { data: articles } = await supabase
      .from("licenses")
      .select("id, title, source_url, human_price, ai_price, licensing_enabled")
      .eq("publisher_id", publisherId)
      .order("created_at", { ascending: false });

    const allArticles = articles || [];
    const licensedArticles = allArticles.filter(a => a.licensing_enabled);
    const unlicensedArticles = allArticles.filter(a => !a.licensing_enabled);

    // Articles with AI prices set (available for AI licensing)
    const aiLicensable = licensedArticles.filter(a => a.ai_price && Number(a.ai_price) > 0);
    // Articles with no AI price (should be blocked from AI crawlers)
    const aiBlocked = allArticles.filter(a => !a.ai_price || Number(a.ai_price) <= 0);

    // Get licensing stats
    const articleIds = allArticles.map(a => a.id);
    let totalLicenses = 0;
    let aiLicenses = 0;
    if (articleIds.length > 0) {
      const { data: txs } = await supabase
        .from("license_transactions")
        .select("license_type")
        .in("article_id", articleIds)
        .eq("status", "completed");
      totalLicenses = txs?.length || 0;
      aiLicenses = txs?.filter(t => t.license_type === "ai").length || 0;
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;

    // Return based on format
    if (format === "robots") {
      return generateRobotsTxt(publisher, aiBlocked, aiLicensable, supabaseUrl);
    }

    if (format === "ai_txt") {
      return generateAiTxt(publisher, licensedArticles, aiLicensable, supabaseUrl);
    }

    // Default: JSON response with all data
    return successResponse({
      publisher: {
        name: publisher.name,
        website_url: publisher.website_url,
      },
      policy: {
        total_articles: allArticles.length,
        licensed_articles: licensedArticles.length,
        ai_licensable_articles: aiLicensable.length,
        blocked_from_ai: aiBlocked.length,
        total_licenses_issued: totalLicenses,
        ai_licenses_issued: aiLicenses,
      },
      ai_crawlers_blocked: AI_CRAWLERS,
      blocked_urls: aiBlocked
        .filter(a => a.source_url)
        .map(a => a.source_url),
      licensable_urls: aiLicensable
        .filter(a => a.source_url)
        .map(a => ({
          url: a.source_url,
          ai_price: a.ai_price,
          licensing_url: `${supabaseUrl}/functions/v1/create-checkout`,
        })),
      generated_files: {
        robots_txt: `${supabaseUrl}/functions/v1/ai-defense-policy?publisher_id=${publisherId}&format=robots`,
        ai_txt: `${supabaseUrl}/functions/v1/ai-defense-policy?publisher_id=${publisherId}&format=ai_txt`,
      },
    });
  } catch (error) {
    const msg = error instanceof Error ? error.message : "Unknown error";
    console.error("[ai-defense-policy] Error:", msg);
    return errorResponse("Internal server error", 500);
  }
});

function generateRobotsTxt(
  publisher: any,
  blockedArticles: any[],
  licensableArticles: any[],
  supabaseUrl: string,
): Response {
  const lines: string[] = [
    `# =============================================================`,
    `# AI Defense Policy — Generated by Opedd Protocol`,
    `# Publisher: ${publisher.name}`,
    `# Generated: ${new Date().toISOString()}`,
    `# =============================================================`,
    `#`,
    `# This file blocks AI crawlers from scraping unlicensed content.`,
    `# To license this content for AI training, visit:`,
    `# ${supabaseUrl}/functions/v1/ai-defense-policy?publisher_id=${publisher.id}`,
    `#`,
    `# Learn more: https://opedd.com/protocol`,
    `# =============================================================`,
    ``,
  ];

  // Block AI crawlers from unlicensed URLs
  const blockedUrls = blockedArticles.filter(a => a.source_url);
  if (blockedUrls.length > 0) {
    for (const crawler of AI_CRAWLERS) {
      lines.push(`User-agent: ${crawler}`);
      for (const article of blockedUrls) {
        // Extract path from URL
        try {
          const path = new URL(article.source_url).pathname;
          lines.push(`Disallow: ${path}`);
        } catch {
          // If URL parsing fails, use as-is
          lines.push(`Disallow: ${article.source_url}`);
        }
      }
      lines.push(``);
    }
  } else {
    // If all content is licensable, still declare policy
    for (const crawler of AI_CRAWLERS) {
      lines.push(`User-agent: ${crawler}`);
      lines.push(`# All content available for licensing via Opedd Protocol`);
      lines.push(`Crawl-delay: 10`);
      lines.push(``);
    }
  }

  // Ai.txt reference
  lines.push(`# For structured AI licensing information, see ai.txt:`);
  lines.push(`# ${supabaseUrl}/functions/v1/ai-defense-policy?publisher_id=${publisher.id}&format=ai_txt`);

  return new Response(lines.join("\n"), {
    status: 200,
    headers: {
      ...corsHeaders,
      "Content-Type": "text/plain; charset=utf-8",
      "Cache-Control": "public, max-age=3600",
    },
  });
}

function generateAiTxt(
  publisher: any,
  licensedArticles: any[],
  aiLicensable: any[],
  supabaseUrl: string,
): Response {
  const lines: string[] = [
    `# =============================================================`,
    `# ai.txt — AI Training & Ingestion Policy`,
    `# Generated by Opedd Protocol`,
    `# Publisher: ${publisher.name}`,
    `# Generated: ${new Date().toISOString()}`,
    `# =============================================================`,
    ``,
    `# Policy Declaration`,
    `User-Agent: *`,
    `Preference: opt-out`,
    `# Default: AI training is not permitted without a license.`,
    ``,
    `# Licensing`,
    `License-Protocol: opedd/1.0`,
    `License-API: ${supabaseUrl}/functions/v1/create-checkout`,
    `License-Info: https://opedd.com/protocol`,
    ``,
    `# Contact`,
    `Publisher: ${publisher.name}`,
    ...(publisher.website_url ? [`Website: ${publisher.website_url}`] : []),
    ``,
  ];

  // Licensed content section
  if (aiLicensable.length > 0) {
    lines.push(`# Licensed Content Available`);
    lines.push(`# The following content is available for AI training via paid license:`);
    lines.push(``);
    for (const article of aiLicensable) {
      if (article.source_url) {
        lines.push(`Allow: ${article.source_url}`);
        lines.push(`License-Price: $${Number(article.ai_price).toFixed(2)} USD`);
        lines.push(`License-Type: ai_training`);
        lines.push(``);
      }
    }
  }

  // Blocked content
  const blocked = licensedArticles.filter(a => !a.ai_price || Number(a.ai_price) <= 0);
  if (blocked.length > 0) {
    lines.push(`# Restricted Content (no AI license available)`);
    for (const article of blocked) {
      if (article.source_url) {
        lines.push(`Disallow: ${article.source_url}`);
      }
    }
    lines.push(``);
  }

  lines.push(`# =============================================================`);
  lines.push(`# To obtain AI training licenses programmatically:`);
  lines.push(`# POST ${supabaseUrl}/functions/v1/create-checkout`);
  lines.push(`# Body: { "article_id": "<id>", "license_type": "ai", "buyer_email": "<email>" }`);
  lines.push(`# =============================================================`);

  return new Response(lines.join("\n"), {
    status: 200,
    headers: {
      ...corsHeaders,
      "Content-Type": "text/plain; charset=utf-8",
      "Cache-Control": "public, max-age=3600",
    },
  });
}
